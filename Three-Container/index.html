<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>3dviewerï¼šé›†æˆæ‰‹åŠ¿é©±åŠ¨</title>
  <!-- Three.js ä¸ OBJ/MTLåŠ è½½å™¨ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
  <!-- å¼•å…¥ TensorFlow.js ä¸ handpose æ¨¡å‹ï¼ˆå¯ç”¨æ‰‹åŠ¿äº¤äº’æ—¶éœ€è¦ï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@latest"></script>
  <style>
    :root {
      --bg-color: #121212;
      --surface-color: #242424;
      --text-primary: #ffffff;
    }
    body {
      margin: 0;
      background: var(--bg-color);
      color: var(--text-primary);
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    three-container {
      display: block;
      position: relative;
      border: 1px solid var(--surface-color);
      border-radius: 8px;
      overflow: hidden;
      margin: 20px auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 100;
      backdrop-filter: blur(4px);
    }
    .controls-tip {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0,0,0,0.7);
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.6;
    }
    /* éšè—æ‰‹åŠ¿è§†é¢‘ */
    .gesture-container { display: none; }
  </style>
</head>
<body>
  <h1 style="text-align: center; margin: 24px 0;">3dviewerï¼šé›†æˆæ‰‹åŠ¿é©±åŠ¨</h1>
  
  <!-- ç¤ºä¾‹ï¼šè‡ªåŠ¨æ—‹è½¬å¼€å¯ã€å…‰æºä¸ç›¸æœºä½ç½®è‡ªå®šä¹‰ï¼ŒåŒæ—¶å¯ç”¨æ‰‹åŠ¿äº¤äº’ -->
  <three-container 
    src="./model/example.obj"
    mtl="./model/example.mtl"
    width="800"
    height="600"
    alt="ç¤ºä¾‹æ¨¡å‹"
    auto-display="false"
    light-position="5,5,5; -5,3,2"
    camera-position="10"
    gesture-control="true"
  ></three-container>
  
<!--auto-display-speed="0.005" -->
  <div class="controls-tip">
    ğŸ® æ“ä½œæ§åˆ¶ï¼š<br>
    â€¢ é¼ æ ‡æ‹–æ‹½ï¼šæ—‹è½¬æ¨¡å‹<br>
    â€¢ æ»šè½®ï¼šç¼©æ”¾è§†å›¾<br>
    â€¢ WASD/æ–¹å‘é”®ï¼šç§»åŠ¨è§†è§’<br>
    â€¢ Q/Eï¼šå‡é™é«˜åº¦<br>
    è‡ªåŠ¨æ—‹è½¬ï¼šå¼€å¯/å…³é—­ï¼ˆç”¨æˆ·æ“ä½œæ—¶è‡ªåŠ¨æš‚åœï¼‰<br>
    å…‰æºä½ç½®ï¼šå¯è‡ªå®šä¹‰å¤šä¸ªå…‰æº<br>
    ç›¸æœºä½ç½®ï¼šå¯æŒ‡å®šç»å¯¹åæ ‡ï¼ˆå¦‚â€œ2,3,10â€ï¼‰æˆ–è·ç¦»ï¼ˆå¦‚â€œ10â€ï¼‰<br>
    æ‰‹åŠ¿äº¤äº’ï¼šå¯ç”¨åï¼Œé€šè¿‡æ‹‡æŒ‡ä¸é£ŸæŒ‡æ¥è§¦æ§åˆ¶æ¨¡å‹æ‹–æ‹½
  </div>

<script>
class ThreeContainer extends HTMLElement {
  static get observedAttributes() {
    return [
      'src', 'mtl', 'width', 'height', 'alt', 
      'auto-display', 'auto-display-speed', 'light-position', 
      'camera-position', 'gesture-control'
    ];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    // åˆå§‹åŒ–å®šå‘å…‰æ•°ç»„
    this.directionalLights = [];
    this.initElements();
    this.initScene();
    this.keyState = {};
    this.cameraTarget = new THREE.Vector3(0, 0, 0);
    // è‡ªåŠ¨æ—‹è½¬ç›¸å…³å˜é‡
    this.autoRotate = false;
    this.autoRotateSpeed = 0.005;
    this.userInteracting = false;
    this.resumeAutoRotateTimer = null;
    // æ‰‹åŠ¿äº¤äº’ç›¸å…³å˜é‡
    this.gestureControlEnabled = false;
    this.handposeModel = null;
    this.prevFingerPos = null; // ä¸Šä¸€å¸§é£ŸæŒ‡ä½ç½®
    this.gestureThreshold = 40;  // æ‹‡æŒ‡ä¸é£ŸæŒ‡æ¥è§¦é˜ˆå€¼ï¼ˆåƒç´ ï¼‰
    // å¹³æ»‘ç³»æ•°ä¸çµæ•åº¦è°ƒæ•´ï¼šå¹³æ»‘ç³»æ•°è¾ƒå¤§ï¼Œä½ç§»æ˜ å°„ç³»æ•°é™ä½
    //
    //
    //
    this.smoothingFactor = 0.1;//æ ¸å¿ƒå‚æ•°
    this.positionMultiplier = 0.005;//æ ¸å¿ƒå‚æ•°
    //
    //
    //
    //
  }

  initElements() {
    // åŠ è½½é®ç½©
    this.loadingElement = document.createElement('div');
    this.loadingElement.className = 'loading-overlay';
    this.loadingElement.innerHTML = `
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2">
        <path d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83"/>
      </svg>
      <div style="margin-top:12px;">åŠ è½½ä¸­...</div>
    `;
    this.shadowRoot.appendChild(this.loadingElement);

    if (this.getAttribute('gesture-control') === 'true') {
      this.gestureControlEnabled = true;
      const gestureContainer = document.createElement('div');
      gestureContainer.className = 'gesture-container';
      gestureContainer.innerHTML = `<video autoplay id="gestureVideo" width="60" height="40" style="transform: scaleX(-1);"></video>`;
      this.shadowRoot.appendChild(gestureContainer);
    }
  }

  initScene() {
    this.scene = new THREE.Scene();
    this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    this.renderer.setClearColor(0x000000);
    
    // åˆå§‹åŒ–ç›¸æœº
    this.camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
    // åˆå§‹ä½ç½®å°†åœ¨ adjustCamera ä¸­è®¾ç½®

    // æ·»åŠ ç¯å¢ƒå…‰ï¼ˆå§‹ç»ˆå­˜åœ¨ï¼‰
    const ambient = new THREE.AmbientLight(0xffffff, 0.3);
    this.scene.add(ambient);

    // è®¾ç½®å®šå‘å…‰ï¼ˆå…‰æºä½ç½®å¯è‡ªå®šä¹‰ï¼‰
    this.setupLights();
  }

  setupLights() {
    this.directionalLights.forEach(light => this.scene.remove(light));
    this.directionalLights = [];
    const lightPosAttr = this.getAttribute('light-position');
    if (lightPosAttr) {
      const positions = lightPosAttr.split(';').map(s => s.trim()).filter(s => s);
      positions.forEach(posStr => {
        const coords = posStr.split(',').map(Number);
        if (coords.length >= 3 && coords.every(num => !isNaN(num))) {
          const directional = new THREE.DirectionalLight(0xffffff, 0.8);
          directional.position.set(coords[0], coords[1], coords[2]);
          this.scene.add(directional);
          this.directionalLights.push(directional);
        }
      });
    }
    if (this.directionalLights.length === 0) {
      const defaultLight = new THREE.DirectionalLight(0xffffff, 0.8);
      defaultLight.position.set(5, 5, 5);
      this.scene.add(defaultLight);
      this.directionalLights.push(defaultLight);
    }
  }

  connectedCallback() {
    this.updateSize();
    this.shadowRoot.appendChild(this.renderer.domElement);
    this.setupEventListeners();
    this.autoRotate = this.getAttribute('auto-display') === 'true';
    const speedAttr = this.getAttribute('auto-display-speed');
    if (speedAttr) this.autoRotateSpeed = parseFloat(speedAttr);
    this.loadModel();
    this.startRendering();
    if (this.gestureControlEnabled) this.initGestureControl();
  }

  attributeChangedCallback(name) {
    if (['width', 'height'].includes(name)) this.updateSize();
    if(name === 'auto-display') this.autoRotate = this.getAttribute('auto-display') === 'true';
    if(name === 'auto-display-speed'){
      const speedAttr = this.getAttribute('auto-display-speed');
      if (speedAttr) this.autoRotateSpeed = parseFloat(speedAttr);
    }
    if(name === 'light-position') this.setupLights();
    if(name === 'camera-position') this.adjustCamera();
    if(name === 'gesture-control'){
      this.gestureControlEnabled = this.getAttribute('gesture-control') === 'true';
      if (this.gestureControlEnabled && !this.handposeModel) this.initGestureControl();
    }
  }

  updateSize() {
    const width = parseInt(this.getAttribute('width')) || 800;
    const height = parseInt(this.getAttribute('height')) || 600;
    this.style.width = `${width}px`;
    this.style.height = `${height}px`;
    this.renderer.setSize(width, height);
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
  }

  async loadModel() {
    try {
      this.showLoading();
      await this.loadModelData();
      this.processModel();
    } catch (error) {
      this.showError(error ? error.toString() : 'åŠ è½½æ¨¡å‹æ—¶å‡ºé”™');
    } finally {
      this.hideLoading();
    }
  }

  async loadModelData() {
    const src = this.getAttribute('src');
    if (!src) throw new Error('æ¨¡å‹è·¯å¾„æœªæŒ‡å®š');
    if (src.toLowerCase().endsWith('.obj')) await this.loadOBJWithMTL();
  }

  async loadOBJWithMTL() {
    let [objPath, mtlPath] = this.getModelPaths();
    let materials;
    try {
      if (mtlPath.includes('/')) {
        materials = await new THREE.MTLLoader().loadAsync(mtlPath);
      } else {
        const basePath = this.getBasePath(objPath);
        materials = await new THREE.MTLLoader().setPath(basePath).loadAsync(mtlPath);
      }
      materials.preload();
    } catch (error) {
      console.warn('ä½¿ç”¨é»˜è®¤æè´¨:', error);
      materials = this.createFallbackMaterial();
    }
    this.model = await new THREE.OBJLoader().setMaterials(materials).loadAsync(objPath);
  }

  getModelPaths() {
    const objSrc = this.getAttribute('src');
    const mtlSrc = this.getAttribute('mtl') || objSrc.replace(/\.obj$/i, '.mtl');
    return [objSrc, mtlSrc];
  }

  getBasePath(filePath) {
    return filePath.substring(0, filePath.lastIndexOf('/') + 1);
  }

  createFallbackMaterial() {
    const material = new THREE.MeshPhongMaterial({ color: 0x888888, specular: 0x111111, shininess: 30 });
    return { create: () => material };
  }

  processModel() {
    this.scene.add(this.model);
    this.centerModel();
    this.adjustCamera();
  }

  centerModel() {
    const box = new THREE.Box3().setFromObject(this.model);
    const center = box.getCenter(new THREE.Vector3());
    this.model.position.sub(center);
    const size = box.getSize(new THREE.Vector3());
    const scale = 5 / Math.max(size.x, size.y, size.z);
    this.model.scale.set(scale, scale, scale);
  }

  adjustCamera() {
    if (!this.model) return;
    const box = new THREE.Box3().setFromObject(this.model);
    const size = box.getSize(new THREE.Vector3());
    let defaultDistance = size.length() * 2;
    const cameraPosAttr = this.getAttribute('camera-position');
    if (cameraPosAttr) {
      const parts = cameraPosAttr.split(',').map(s => parseFloat(s.trim())).filter(n => !isNaN(n));
      if (parts.length === 1) {
        this.camera.position.set(0, 0, parts[0]);
      } else if (parts.length >= 3) {
        this.camera.position.set(parts[0], parts[1], parts[2]);
      } else {
        this.camera.position.set(0, 0, defaultDistance);
      }
    } else {
      this.camera.position.set(0, 0, defaultDistance);
    }
    this.camera.lookAt(this.cameraTarget);
    this.camera.updateProjectionMatrix();
  }

  setupEventListeners() {
    let isDragging = false, prevX = 0, prevY = 0;
    const onMouseDown = e => {
      isDragging = true;
      prevX = e.clientX;
      prevY = e.clientY;
      this.pauseAutoRotate();
    };
    const onMouseMove = e => {
      if (!isDragging || !this.model) return;
      const deltaX = e.clientX - prevX, deltaY = e.clientY - prevY;
      this.model.rotation.y += deltaX * 0.005;
      this.model.rotation.x += deltaY * 0.005;
      prevX = e.clientX;
      prevY = e.clientY;
    };
    const onMouseUp = () => { isDragging = false; this.resumeAutoRotateAfterDelay(); };
    this.addEventListener('mousedown', onMouseDown);
    this.addEventListener('mousemove', onMouseMove);
    this.addEventListener('mouseup', onMouseUp);
    this.addEventListener('mouseleave', onMouseUp);
    this.addEventListener('wheel', e => {
      e.preventDefault();
      this.pauseAutoRotate();
      const delta = e.deltaY * 0.002;
      this.camera.translateZ(delta * 15);
      this.camera.lookAt(this.cameraTarget);
      this.resumeAutoRotateAfterDelay();
    }, { passive: false });
    this._onKeyDown = e => { this.keyState[e.key.toLowerCase()] = true; this.pauseAutoRotate(); };
    this._onKeyUp = e => { this.keyState[e.key.toLowerCase()] = false; this.resumeAutoRotateAfterDelay(); };
    window.addEventListener('keydown', this._onKeyDown);
    window.addEventListener('keyup', this._onKeyUp);
  }

  pauseAutoRotate() {
    this.userInteracting = true;
    if (this.resumeAutoRotateTimer) { clearTimeout(this.resumeAutoRotateTimer); this.resumeAutoRotateTimer = null; }
  }

  resumeAutoRotateAfterDelay() {
    if (!this.autoRotate) return;
    if (this.resumeAutoRotateTimer) clearTimeout(this.resumeAutoRotateTimer);
    this.resumeAutoRotateTimer = setTimeout(() => { this.userInteracting = false; }, 1000);
  }

  handleCameraMovement() {
    const baseSpeed = 0.15, speed = this.keyState.shift ? baseSpeed * 2 : baseSpeed;
    if (this.keyState.w || this.keyState.arrowup) this.camera.translateZ(-speed);
    if (this.keyState.s || this.keyState.arrowdown) this.camera.translateZ(speed);
    if (this.keyState.a || this.keyState.arrowleft) this.camera.translateX(-speed);
    if (this.keyState.d || this.keyState.arrowright) this.camera.translateX(speed);
    if (this.keyState.q) this.camera.position.y += speed;
    if (this.keyState.e) this.camera.position.y -= speed;
    this.camera.lookAt(this.cameraTarget);
  }

  startRendering() {
    const animate = () => {
      requestAnimationFrame(animate);
      this.handleCameraMovement();
      if (this.autoRotate && !this.userInteracting && this.model) {
        this.model.rotation.y += this.autoRotateSpeed;
      }
      this.renderer.render(this.scene, this.camera);
    };
    animate();
  }

  async initGestureControl() {
    try {
      const videoElem = this.shadowRoot.getElementById('gestureVideo');
      if (!videoElem) return;
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      videoElem.srcObject = stream;
      await new Promise(resolve => videoElem.onloadedmetadata = () => resolve(videoElem));
      this.handposeModel = await handpose.load();
      console.log('æ‰‹åŠ¿æ¨¡å‹åŠ è½½å®Œæˆ');
      this.detectHands();
    } catch (err) {
      console.error('æ‰‹åŠ¿æ§åˆ¶åˆå§‹åŒ–å¤±è´¥:', err);
    }
  }

  // æ‰‹åŠ¿æ£€æµ‹ï¼šæ£€æµ‹æ‹‡æŒ‡ä¸é£ŸæŒ‡æ¥è§¦æ—¶ï¼Œæ¨¡æ‹Ÿé¼ æ ‡é•¿æŒ‰æ‹–æ‹½æ¨¡å‹ï¼ˆå¹³ç§» x å’Œ yï¼‰
  async detectHands() {
    if (!this.handposeModel) return;
    const videoElem = this.shadowRoot.getElementById('gestureVideo');
    if (!videoElem) return;
    const predictions = await this.handposeModel.estimateHands(videoElem);
    if (predictions.length > 0) {
      const landmarks = predictions[0].landmarks;
      const thumbTip = landmarks[4], indexTip = landmarks[8];
      // åˆ¤æ–­æ˜¯å¦æ¥è§¦
      if (Math.hypot(thumbTip[0] - indexTip[0], thumbTip[1] - indexTip[1]) < this.gestureThreshold) {
        // å°†é£ŸæŒ‡åæ ‡é•œåƒè½¬æ¢ï¼ˆä»… x åæ ‡ç¿»è½¬ï¼‰å¹¶æ˜ å°„åˆ°çª—å£åæ ‡
        const mapped = { x: 640 - indexTip[0], y: indexTip[1] };
        const winPos = {
          x: (mapped.x / 640) * window.innerWidth,
          y: (mapped.y / 480) * window.innerHeight
        };
        // å¹³æ»‘å¤„ç†ï¼šæ›´æ–°è®°å½•ï¼Œé™ä½çµæ•åº¦
        if (this.prevFingerPos) {
          const deltaX = (winPos.x - this.prevFingerPos.x) * this.positionMultiplier;
          const deltaY = (winPos.y - this.prevFingerPos.y) * this.positionMultiplier;
          this.model.rotation.x += deltaY*0.2;//æ ¸å¿ƒå‚æ•°
          this.model.rotation.y += deltaX*0.2;//æ ¸å¿ƒå‚æ•°
        }
        // æ›´æ–°å¹³æ»‘è®°å½•ï¼ˆé‡‡ç”¨è¾ƒå¤§å¹³æ»‘ç³»æ•°ï¼Œä¿è¯ç¼“æ…¢è·Ÿéšï¼‰
        if (!this.prevFingerPos) {
          this.prevFingerPos = winPos;
        } else {
          this.prevFingerPos.x = this.prevFingerPos.x + this.smoothingFactor * (winPos.x - this.prevFingerPos.x);
          this.prevFingerPos.y = this.prevFingerPos.y + this.smoothingFactor * (winPos.y - this.prevFingerPos.y);
        }
      } else {
        this.prevFingerPos = null;
      }
    } else {
      this.prevFingerPos = null;
    }
    requestAnimationFrame(() => this.detectHands());
  }

  showLoading() {
    this.loadingElement.style.display = 'flex';
  }

  hideLoading() {
    this.loadingElement.style.display = 'none';
  }

  showError(message) {
    this.loadingElement.innerHTML = `
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#ff4444" stroke-width="2">
        <path d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
      </svg>
      <div style="color:#ff4444; margin-top:12px;">${message}</div>
    `;
  }

  disconnectedCallback() {
    window.removeEventListener('keydown', this._onKeyDown);
    window.removeEventListener('keyup', this._onKeyUp);
    this.renderer.dispose();
    if (this.model) {
      this.model.traverse(child => {
        if (child.material) child.material.dispose();
        if (child.geometry) child.geometry.dispose();
      });
    }
  }
}

customElements.define('three-container', ThreeContainer);
</script>
</body>
</html>
